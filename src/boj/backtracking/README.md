# BOJ 15649 - N과 M (1)

## 문제 요약
1부터 N까지의 자연수 중에서 중복 없이 M개를 고른 순열을 모두 출력하는 문제

## 알고리즘 분류
- 백트래킹 (Backtracking)
- 순열 (Permutation)

## 해결 방법
- 재귀를 이용해 숫자를 하나씩 선택
- 방문 배열로 중복 선택 방지
- 재귀 종료 후 상태를 원상 복구하여 모든 경우 탐색

## 시간 복잡도
- O(N! / (N-M)!)

# BOJ 15650 - N과 M (2)

## 문제 요약
1부터 N까지의 자연수 중에서 중복 없이 M개를 고른 수열을 출력
(수열은 **오름차순**이어야 한다.)

## 해결 방법
- DFS를 사용해 중첩 for문 구조를 일반화
- 이전에 선택한 값보다 큰 수만 선택하도록 제한
- 오름차순 조건을 활용해 visited 배열 없이 중복 제거

## 핵심 포인트
- depth: 현재 선택한 숫자의 개수
- last: 직전에 선택한 값
- 다음 숫자는 `last + 1`부터 선택

## 시간 복잡도
- O(C(N, M))

# BOJ15651 - N과 M (3)

## 문제 요약
- 입력: 두 정수 N, M (1 ≤ M ≤ N ≤ 8)
- 출력: 1~N까지 수로 길이 M인 중복순열을 사전순으로 출력

## 해결 방법
- `dfs(depth)`를 사용하여 현재 깊이에 맞는 수를 선택
- `depth == M`이면 결과를 `StringBuilder`에 저장
- 반복문으로 1~N까지 수를 선택하며 재귀 호출
- `StringBuilder`를 사용해 출력 효율 최적화

## 시간 복잡도
- O(N^M)

## 공간 복잡도
- O(M)

# BOJ 15652 - N과 M (4)

## 문제 요약
- 백준 15652번: N개의 자연수 중 M개를 고른 수열
- 중복 가능, 비내림차순 수열만 출력

## 해결 방법
- DFS(재귀)를 이용한 백트래킹
- depth`와 `last 변수를 사용해 비내림차순 유지

## 핵심 포인트
1. depth = 현재 선택한 수의 개수
2. last = 이전에 선택한 수 → 반복/비내림차순 유지
3. 재귀 종료 조건: depth == M → 수열 출력
4. for문으로 `last`부터 N까지 탐색

## 시간 복잡도
- O(N^M)

## 공간 복잡도
- O(M)

# BOJ 15654 - N과 M (5)

## 문제 요약
N개의 자연수 중에서 중복 없이 M개를 선택해 만들 수 있는 모든 수열을
사전 순으로 출력하는 문제이다.

## 해결 방법
- 입력 숫자를 오름차순 정렬
- 백트래킹(DFS) 사용
- visit 배열로 중복 선택 방지
- 수열 길이가 M이 되면 출력

## 시간 복잡도
- O(N! / (N - M)!)

## 공간 복잡도
- O(N + M)

# BOJ 15655 - N과 M (6)

## 문제 요약
N개의 자연수 중에서 중복 없이 M개를 선택하여 만들 수 있는 모든 조합을
사전 순으로 출력하는 문제

## 해결 방법
- 입력 숫자를 오름차순 정렬
- 백트래킹(DFS) 사용
- 시작 인덱스(last)를 이용해 오름차순 선택
- 수열 길이가 M이 되면 출력

## 시간 복잡도
O(C(N, M))

## 공간 복잡도
O(N + M)

# BOJ 15656 - N과 M (7)

## 문제 요약
N개의 자연수 중에서 중복을 허용하여 M개를 선택해 만들 수 있는 모든 수열을
사전 순으로 출력하는 문제

## 해결 방법
- 입력 숫자를 오름차순 정렬
- 백트래킹(DFS) 사용
- 중복 선택을 허용하므로 visit 배열 사용 안 함
- 수열 길이가 M이 되면 출력

## 시간 복잡도
O(N^M)
- 각 자리에 N가지 선택 가능
- 수열 출력에 O(M)

## 공간 복잡도
O(N + M)
- 입력 배열(nums): O(N)
- 결과 배열(arr): O(M)
- 재귀 호출 스택: O(M)

# BOJ 15657 - N과 M (8)

## 문제 요약
N개의 자연수 중에서 중복을 허용하며, 비내림차순으로 M개를 선택해 만들 수 있는 모든 수열을
사전 순으로 출력하는 문제

## 해결 방법
- 입력 숫자를 오름차순 정렬
- 백트래킹(DFS) 사용
- 시작 인덱스(last)를 이용해 오름차순 선택
- 중복 허용
- 수열 길이가 M이 되면 출력

## 시간 복잡도
O(C(N + M - 1, M))
- 중복 조합 공식 적용
- 각 수열 출력에 O(M)

## 공간 복잡도
O(N + M)
- 입력 배열(nums): O(N)
- 결과 배열(arr): O(M)
- 재귀 호출 스택: O(M)

# BOJ 15663 - N과 M (9)

## 해결 방법
- 입력 수열을 정렬하여 사전 순 출력 보장
- visited 배열을 사용해 같은 인덱스의 중복 사용 방지
- 같은 depth에서 이전에 선택한 값을 prev 변수로 관리하여 중복 제거
- DFS(백트래킹)를 이용해 모든 경우 탐색

## 핵심 포인트
- 값이 같아도 인덱스가 다르면 다른 수로 처리
- 같은 depth에서는 같은 값 한 번만 선택

## 시간 복잡도
- O(N! / (N - M)!)

# BOJ 15664 - N과 M (10)

## 문제 설명
N개의 자연수 중에서 M개를 고른 **조합**을 출력
- 입력에 중복된 수가 있을 수 있음
- 같은 수열은 한 번만 출력
- 출력은 사전 순 (오름차순)

## 해결 방법
- 입력 배열 `nums`를 정렬 → 사전 순 출력 보장
- DFS(백트래킹) + 조합 탐색 → depth마다 이전 index 이후만 탐색
- 같은 depth에서 같은 값 선택 방지 → prev 변수 사용
- visited 배열 없이, `i+1`로 index 범위 제한 → 코드 간결

## 핵심 포인트
- prev + 정렬 → 중복 수열 제거
- DFS에서 last = i+1 → 같은 index 재사용 방지 + 비내림차순 유지

## 시간 복잡도
- 최악: O(N! / (N-M)!)
- 정렬 + prev로 불필요한 탐색 제거
