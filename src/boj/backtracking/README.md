# BOJ 15649 - N과 M (1)

## 문제 요약
1부터 N까지의 자연수 중에서 중복 없이 M개를 고른 순열을 모두 출력하는 문제

## 알고리즘 분류
- 백트래킹 (Backtracking)
- 순열 (Permutation)

## 해결 방법
- 재귀를 이용해 숫자를 하나씩 선택
- 방문 배열로 중복 선택 방지
- 재귀 종료 후 상태를 원상 복구하여 모든 경우 탐색

## 시간 복잡도
- O(N! / (N-M)!)

# BOJ 15650 - N과 M (2)

## 문제 요약
1부터 N까지의 자연수 중에서 중복 없이 M개를 고른 수열을 출력
(수열은 **오름차순**이어야 한다.)

## 해결 방법
- DFS를 사용해 중첩 for문 구조를 일반화
- 이전에 선택한 값보다 큰 수만 선택하도록 제한
- 오름차순 조건을 활용해 visited 배열 없이 중복 제거

## 핵심 포인트
- depth: 현재 선택한 숫자의 개수
- last: 직전에 선택한 값
- 다음 숫자는 `last + 1`부터 선택

## 시간 복잡도
- O(C(N, M))

# BOJ15651 - N과 M (3)

## 문제 요약
- 입력: 두 정수 N, M (1 ≤ M ≤ N ≤ 8)
- 출력: 1~N까지 수로 길이 M인 중복순열을 사전순으로 출력

## 해결 방법
- `dfs(depth)`를 사용하여 현재 깊이에 맞는 수를 선택
- `depth == M`이면 결과를 `StringBuilder`에 저장
- 반복문으로 1~N까지 수를 선택하며 재귀 호출
- `StringBuilder`를 사용해 출력 효율 최적화

## 시간 복잡도
- O(N^M)

## 공간 복잡도
- O(M)


