# BOJ 1260 - DFS와 BFS

## 문제 요약
그래프가 주어졌을 때 시작 정점에서 **DFS와 BFS 탐색 결과**를 출력
정점은 **번호가 작은 것부터 방문**

## 해결 방법
- 인접 리스트(`ArrayList<Integer>[]`)로 그래프 구성
- 각 정점의 인접 리스트를 오름차순 정렬
- DFS는 재귀로 구현
- BFS는 Queue를 사용해 구현

## 시간 복잡도
- O(N + M)

## 사용 알고리즘
- 그래프 탐색
- DFS, BFS

# BOJ 2178 - 미로 탐색

## 문제 설명
- BFS를 이용해 미로에서 **최단 이동 거리**를 구하는 문제
- 시작점 (0,0)에서 도착점 (N-1, M-1)까지 이동하는 최소 칸 수 계산

## 해결 방법
- Queue를 사용한 BFS 탐색
- 상, 하, 좌, 우 네 방향 이동
- 방문 여부를 체크하여 중복 탐색 방지
- 이동 거리 정보를 map 배열에 누적 저장

## 시간 복잡도
- O(N × M)

## 사용 알고리즘
- BFS
- Queue (LinkedList)

# BOJ 2606 - 바이러스(인접행렬)

## 문제 설명
- 컴퓨터 네트워크가 주어졌을 때 1번 컴퓨터를 통해 바이러스에 걸리는 컴퓨터 수를 구하는 문제
- 연결 정보가 주어지고, 연결된 컴퓨터는 양방향 연결이다.

## 시간 복잡도
- O(N^2) (인접 행렬 사용)

## 사용 알고리즘
- BFS
- Queue (LinkedList)
- 인접 행렬(int[][])로 그래프 구성

# BOJ 2606 - 바이러스(인접리스트)

## 시간 복잡도
- O(N + M)

## 사용 알고리즘
- BFS
- Queue (LinkedList)
- 인접리스트(ArrayList<Integer>[])로 그래프 구성

# BOJ 1012 - 유기농 배추

DFS(깊이 우선 탐색)를 이용해 2차원 격자에서
상하좌우로 연결된 배추 영역(연결 요소)의 개수를 구하는 문제

## 해결 방법
- 배추가 있는 위치를 2차원 배열에 저장
- 전체 맵을 순회하며 아직 방문하지 않은 배추를 발견하면 DFS 실행
- DFS로 연결된 모든 배추를 방문 처리
- DFS 호출 횟수를 배추 덩어리 개수로 계산

## 시간 복잡도
- O(N × M)

## 사용 알고리즘
- DFS

# BOJ 11724 - 연결 요소의 개수

## 문제 요약
무방향 그래프가 주어졌을 때, 그래프에 존재하는 연결 요소(Connected Component)의 개수를 구하는 문제  
(연결 요소란 서로 연결되어 있는 정점들의 집합을 의미)

## 해결 방법
- 인접 리스트(ArrayList)를 이용해 그래프를 구성
- DFS(깊이 우선 탐색)를 사용하여 그래프를 탐색
- 방문하지 않은 정점에서 DFS를 시작할 때마다 연결 요소의 개수를 1 증가

## 시간 복잡도
- O(N + M)
    - N: 정점의 개수
    - M: 간선의 개수

# BOJ 11725 - 트리의 부모 찾기

## 문제 요약
루트가 1번 노드인 트리가 주어질 때,
각 노드의 부모 노드 번호를 구하는 문제

## 해결 방법
- 인접 리스트를 사용해 트리를 표현
- DFS(깊이 우선 탐색) 를 이용해 루트(1번 노드)부터 탐색
- 방문하지 않은 노드를 자식으로 처리하고,
  현재 노드를 해당 노드의 부모로 저장

## 시간 복잡도
• O(N)






