# BOJ 1463 - 1로 만들기

## 문제 요약
정수 N이 주어질 때, 다음 연산을 사용하여 1로 만드는 최소 연산 횟수를 구한다.

- N이 3으로 나누어 떨어지면 3으로 나눈다
- N이 2로 나누어 떨어지면 2로 나눈다
- 1을 뺀다

## 해결 방법
- dp[i]를 i를 1로 만드는 최소 연산 횟수로 정의
- i-1, i/2, i/3에서 오는 경우 중 최소값 선택
- 이전 값들이 이미 계산되어 있어 Bottom-Up DP 방식 사용
- dp[1] = 0 (초기값)

## 점화식
```text
dp[i] = min(
    dp[i-1] + 1,
    dp[i/2] + 1 (i % 2 == 0),
    dp[i/3] + 1 (i % 3 == 0)
)
```
## 시간 복잡도
- O(N)

## 공간 복잡도
- O(N)

# BOJ 2579 - 계단 오르기

## 📌 문제 요약
- 한 번에 1칸 또는 2칸 이동 가능
- 연속된 3개의 계단을 밟을 수 없음
- 마지막 계단은 반드시 밟아야 함
- 각 계단마다 점수가 주어짐

## 해결 방법
- dp[i]: i번째 계단을 밟았을 때의 최대 점수
- 연속 3계단을 피하기 위해 두 경우 고려

## 점화식
```text
dp[i] = Math.max(dp[i-3] + s[i-1], dp[i-2]) + s[i]
```
## 시간 복잡도
- O(N)

## 공간 복잡도
- O(N)

# BOJ 1149 - RGB 거리

## 문제 요약
- RGB 거리에는 N개의 집이 있고, 각 집은 빨강(R), 초록(G), 파랑(B) 중 하나로 색칠
- 같은 집을 인접한 집과 같은 색으로 칠할 수 없음.
- 각 집을 특정 색으로 칠하는 비용이 주어졌을 때, 전체 비용의 최솟값 구하기

## 해결 방법
- Dynamic Programming을 사용하여 각 집에서 최소 비용을 계산
- dp[i][j]: i번째 집을 j 색으로 칠했을 때의 최소 비용

## 점화식
```text
dp[i][0] = Math.min(dp[i-1][1], dp[i-1][2]) + map[i][0]
dp[i][1] = Math.min(dp[i-1][0], dp[i-1][2]) + map[i][1]
dp[i][2] = Math.min(dp[i-1][0], dp[i-1][1]) + map[i][2]
```
## 시간 복잡도
- O(N)

## 공간 복잡도
- O(N)