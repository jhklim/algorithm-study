# BOJ 1463 - 1로 만들기

## 문제 요약
정수 N이 주어질 때, 다음 연산을 사용하여 1로 만드는 최소 연산 횟수를 구한다.

- N이 3으로 나누어 떨어지면 3으로 나눈다
- N이 2로 나누어 떨어지면 2로 나눈다
- 1을 뺀다

## 해결 방법
- dp[i]를 i를 1로 만드는 최소 연산 횟수로 정의
- i-1, i/2, i/3에서 오는 경우 중 최소값 선택
- 이전 값들이 이미 계산되어 있어 Bottom-Up DP 방식 사용
- dp[1] = 0 (초기값)

## 점화식
```text
dp[i] = min(
    dp[i-1] + 1,
    dp[i/2] + 1 (i % 2 == 0),
    dp[i/3] + 1 (i % 3 == 0)
)
```
## 시간 복잡도
- O(N)

# BOJ 2579 - 계단 오르기

## 📌 문제 요약
- 한 번에 1칸 또는 2칸 이동 가능
- 연속된 3개의 계단을 밟을 수 없음
- 마지막 계단은 반드시 밟아야 함
- 각 계단마다 점수가 주어짐

## 해결 방법
- dp[i]: i번째 계단을 밟았을 때의 최대 점수
- 연속 3계단을 피하기 위해 두 경우 고려

## 점화식
```text
dp[i] = Math.max(dp[i-3] + s[i-1], dp[i-2]) + s[i]
```
## 시간 복잡도
- O(N)

# BOJ 1149 - RGB 거리

## 문제 요약
- RGB 거리에는 N개의 집이 있고, 각 집은 빨강(R), 초록(G), 파랑(B) 중 하나로 색칠
- 같은 집을 인접한 집과 같은 색으로 칠할 수 없음.
- 각 집을 특정 색으로 칠하는 비용이 주어졌을 때, 전체 비용의 최솟값 구하기

## 해결 방법
- Dynamic Programming을 사용하여 각 집에서 최소 비용을 계산
- dp[i][j]: i번째 집을 j 색으로 칠했을 때의 최소 비용

## 점화식
```text
dp[i][0] = Math.min(dp[i-1][1], dp[i-1][2]) + map[i][0]
dp[i][1] = Math.min(dp[i-1][0], dp[i-1][2]) + map[i][1]
dp[i][2] = Math.min(dp[i-1][0], dp[i-1][1]) + map[i][2]
```
## 시간 복잡도
- O(N)

# BOJ 11053 - 가장 긴 증가하는 부분 수열 (LIS)

## 문제 요약
주어진 수열에서 증가하는 부분 수열 중 **가장 긴 길이**를 구하는 문제

## 해결 방법
1. dp[i] = i번째 수를 끝으로 하는 LIS 길이
2. 2중 for문으로 이전 수들과 비교하여 LIS 길이 갱신
3. dp 배열에서 최대값 출력

## 시간 복잡도 
- O(N^2)

# BOJ 12865 - 평범한 배낭

N개의 물건이 주어지고, 각 물건은 **무게(W)**와 **가치(V)**를 가진다.
배낭이 버틸 수 있는 최대 무게 K를 넘지 않도록 물건을 선택했을 때,
가치의 합의 최댓값을 구하는 문제
• 각 물건은 한 번만 선택 가능 (0/1 Knapsack)

해결 방법
1. dp[i]를 무게가 i일 때 얻을 수 있는 최대 가치로 정의
2. 각 물건을 하나씩 순회하며 dp 배열을 갱신
3. 뒤에서부터(j = K → W[i]) 갱신하여 같은 물건이 중복 선택되지 않도록 처리
4. dp[j] = max(dp[j], dp[j - W[i]] + V[i])
5. 최종적으로 dp[K]가 정답

## 핵심 포인트
- 2차원 DP(dp[i][j])를 1차원 DP로 최적화
- j를 감소 방향으로 순회해야 0/1 배낭 조건 유지
- 증가 방향으로 순회하면 **무한 배낭(unbounded knapsack)**이 됨

## 시간 복잡도
O(N * K)
